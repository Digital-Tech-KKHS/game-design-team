# Review your initial game design document. Compare and contrast the game you had initially planned and your final outcome. 

The end result for the game was vastly different from my game design document, but looking back on it, it was based on a similar setting. The game design document stated that I should have an all white, faceless character in third-person that could go through rooms and solve puzzles while a friendly white ghost follows you throughout your progress in the game. The game was intended to find out what happened to the family that once lived in the house and figure out where they went. The game was not intended to be a horror, but instead a puzzle solving game. The game turned out to be horror game with the setting of an asylum. The player follows the character of an asylum patient. The story was not able to be fleshed out all the way as I began to meet time constraints towards the end. The story was originally meant to be an asylum patient waking up in a straight-jacket in a padded-cell room, and a puzzle was supposed to be solved in order for the player to escape out into the hallways. An asylum lady would chase you until you could find another room to hide in. The game was cut short and a lot of mechanics were left out i favour of creating a game that was satisfactory.

# Given each of the initial success criteria that you determined when designing your project, was your game a success? Why or why not? 

I don't believe my game was a success, mainly due to the fact I had run out of time to work on mechanics that were originally intended to be implemented. Most of the intended mechanics were supposed to be implemented had to be scrapped in favour of producing a working, functional game with a win and lose condition.

# Describe the testing process you undertook to ensure your game functioned as intended. 

Most of the testing was done by me, mainly to ensure that my game actually functioned as intended. However, for larger game mechanics and parts of the game that actually affected gameplay, it was handed to play testers that allowed me to fix bugs and mechanics that would've otherwise gone undetected by myself. This included testing for issues with collisions, AI related issues, door opening and closing, unlocking of doors and picking up of the keys.

# Describe your trialing process, and the impact that it had on the development of your outcome.

Trialing was done differently to the testing and was entirely handled by the play testers when the project was nearing completion as I begun to feel the crunch of the project. The reason the trialing was done at the end of the project is mainly because at the beginning of the development cycle, there were no game mechanics and it was all scenery set up that was required to make sure that the game would run smoothly. Towards the end of sprint 4, all the mechanics were implemented and the game begun testing there, hence why all the trailing examples are set at the end of the project.

# Discuss in detail how testing and trialing the components of your game lead to the development of a high quality task. 

During the testing and trialing of the components, my player testers gave me very helpful feedback, mainly when it came to the to the AI roaming and chasing code. One of my play testers called the navigation of the AI "lame" and wished for the AI to chase you into the room if the door was left open. That same play tester also said that the AI should be able to chase the player outside if they leave the escape door open. These were both mechanics that were implemented towards the very end of the game.

# Given the opportunity to develop this game again, what parts of the *process* would you change and why?

If I was to develop this same game again, and given that I do not know what I do and given that I would know the new deadline, I would have switched my development process to the Unity engine as I have a knowledge of the C# language as it is very similar to the Java language. The only reason the Unreal engine was chosen was due to the fact that I thought that I had more time. The original intention was to take advantage of the features of the Unreal engine such as nanite, Niagara and other features such as its procedural generation. 
